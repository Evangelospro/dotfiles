{
    "pwn template":{
        "scope": "python",
        "prefix": "pwn temp",
        "body": [
            "import os",
            "from pwnscripts import * #pip install pwnscripts",
            "",
            "# Lamda helpers",
            "sl = lambda x: io.sendline(x.encode() if type(x) == str else x)",
            "sla = lambda x, y: io.sendlineafter(x.encode() if type(x) == str else x, y.encode() if type(y) == str else y)",
            "se = lambda x: io.send(x.encode() if type(x) == str else x)",
            "sa = lambda x, y: io.sendafter(x.encode() if type(x) == str else x, y.encode() if type(y) == str else y)",
            "",
            "binary_dir = './$1'",
            "elf = ELF(binary_dir, checksec=False)",
            "",
            "host = '$2'",
            "port = $3",
            "def pwn_ssh():",
            "    user = input('ssh user:')",
            "    password = input('ssh password: ')",
            "    return ssh(user=user, host=host, port=port, password=password)",
            "",
            "def pwn_remote():",
            "    return remote(host, port)",
            "",
            "def pwn_gdb():",
            "    context.terminal = ['warp-terminal', '-e']",
            "    gdbscript = '''\ninit-pwndbg\n    continue'''",
            "    return gdb.debug(elf.path, gdbscript)",
            "",
            "def pwn_local():",
            "    return process(elf.path, cwd=binary_dir)",
            "",
            "# Find offset to EIP/RIP for buffer overflows",
            "def find_xip(payload, arch):",
            "    print(f'Finding offset to EIP/RIP for {arch}...')",
            "    # Launch process and send the payload",
            "    io = process(elf.path)",
            "    io.recv()",
            "    io.sendline(payload)",
            "    # Wait for the process to crash",
            "    io.wait()",
            "    # Print out the address of EIP/RIP at the time of crashing",
            "    if 'i386' in arch:",
            "        xip_offset = cyclic_find(io.corefile.pc)  # x86",
            "    elif '64' in arch:",
            "        xip_offset = cyclic_find(io.corefile.read(io.corefile.sp, 4))  # x64",
            "    info('The EIP/RIP offset is ')",
            "    success(str(xip_offset))",
            "    return int(xip_offset)",
            "",
            "def start():",
            "    if args.R:",
            "        return pwn_remote()",
            "    elif args.S:",
            "        return pwn_ssh()",
            "    elif args.L:",
            "        return pwn_local()",
            "    elif args.GDB:",
            "        return pwn_gdb()",
            "    else:",
            "        print('Please select an argument from [REMOTE(R), LOCAL(L), SSH(S), GDB(GDB), ANGR(A)]')",
            "        quit()",
            "padding = find_xip(cyclic(250), elf.get_machine_arch())",
            "io = start()",
            "$0",
            "#io.interactive()",
        ],
    }
}
