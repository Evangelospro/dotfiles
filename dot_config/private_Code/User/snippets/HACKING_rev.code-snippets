{
	"angr z3 template": {
		"scope": "python",
		"prefix": "angr z3 temp",
		"body": [
			"import angr",
			"import claripy",
			"import sys",
			"import os",
			"# from string import printable",
			"",
			"printable = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_{}!?'",
			"binary_path =  './$1'",
			"",
			"def debug(output):",
			"    if len(sys.argv) > 1 and sys.argv[1].lower() == 'debug':",
			"        print(output)",
            "",
            "def is_printable(state, c):",
            "    constraints = [c == ord(char) for char in printable]",
            "    return state.solver.Or(*constraints)",
            "",
			"def successful(state):",
			"    output = state.posix.dumps(sys.stdout.fileno())",
			"    debug(output)",
			"    if b'That key is valid.' in output:",
			"        return True",
			"    return False",
			"",
			"def failed(state):",
			"    output = state.posix.dumps(sys.stdout.fileno())",
			"    debug(output)",
			"    if b'That key is invalid.' in output:",
			"        return True",
			"    return False",
			"",
			"def hook(l=None):",
			"    if l:",
			"        locals().update(l)",
			"    import IPython",
			"    IPython.embed(banner1='', confirm_exit=False)",
			"    exit(0)",
			"",
            "options = {angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY, angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS, angr.options.BYPASS_UNSUPPORTED_SYSCALL} | angr.options.unicorn # unicorn is a bundle option(a set itself), thus we get the union of the two sets",
            "",
			"FIND = ['0x00000000']",
			"AVOID = ['0x00000000']",
            "bytes_per_char = 8 # string - 8, int - 4",
			"inp_len = $2",
			"prefix = '$3{'",
			"suffix = '}'",
			"inp_chars = [claripy.BVS('inp_%d' % i, bytes_per_char) for i in range(inp_len - len(prefix) - len(suffix))]",
			"inp = claripy.Concat(claripy.BVV(bytes(prefix, 'utf-8')), *inp_chars, claripy.BVV(bytes(suffix, 'utf-8')))",
			"project = angr.Project(binary_path, load_options={'auto_load_libs': False})",
			"# STDIN",
			"state = project.factory.full_init_state(args=[binary_path],stdin=inp, add_options=options)",
			"# ARGUMENTS",
			"# state = project.factory.full_init_state(args=[binary_path, inp], add_options=options)",
            "# FILE I/O",
            "# input_file = angr.storage.file.SimFile(name='input.txt', content=inp, has_end=True)",
            "# state = project.factory.full_init_state(args=[binary_path, inp], add_options=options, fs={'input.txt': input_file})",
            "",
			"simgr = project.factory.simulation_manager(state)",
            "# simgr.use_technique(angr.exploration_techniques.DFS())",
            "",
			"for i, k in enumerate(inp_chars):",
			"        # state.solver.add(state.solver.And(k >= 0x20, k <= 0x7e))",
			"        state.solver.add(is_printable(state, k))",
            "",
			"simgr.explore(find=successful, avoid=failed)",
            "",
			"if simgr.found:",
            "    # print(simgr.found[0].posix.dump_file_by_path('input.txt').decode())",
			"    print(simgr.found[0].posix.dumps(sys.stdin.fileno()))",
			"else:",
			"    for errored in simgr.errored:",
            "        # print(simgr.found[0].posix.dump_file_by_path('input.txt').decode())",
			"        print(f'ERRORED {errored.posix.dumps(sys.stdin.fileno())}')",
			"    for deadended in simgr.deadended:",
            "        # print(simgr.found[0].posix.dump_file_by_path('input.txt').decode())",
			"        print(f'DEADENDED {deadended.posix.dumps(sys.stdin.fileno())}')"
		]
	}
}
