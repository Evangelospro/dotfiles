{
    "pwn template":{
        "scope": "python",
        "prefix": "pwn temp",
        "body": [
            "import os",
            "import shutil",
            "from pwn import *",
            "",
            "binary_path = './$1'",
            "context.binary = elf_bin = ELF(binary_path, checksec=False)",
            "rop = ROP(elf_bin)",
            "gdb_api: gdb.Gdb = None",
            "",
            "# Helper functions",
            "def sl(x): io.sendline(x)",
            "def sla(x, y): io.sendlineafter(x, y)",
            "def se(x): io.send(x)",
            "def sa(x, y): io.sendafter(x, y)",
            "def ru(x): return io.recvuntil(x)",
            "def rl(): return io.recvline()",
            "def cl(): return io.clean()",
            "def uu64(x): return u64(x.ljust(8, b'\\x00'))",
            "def uuu(x): return unhex(x[2:])",
            "def raddr(x): return u64(io.recv(6).ljust(8, b'\\x00'))",
            "def log_addr(name,address): info(f'{name} @ {hex(address)}')",
            "",
            "libc_path = './libc.so.6'",
            "if os.path.exists(libc_path):",
            "    libc = ELF(libc_path, checksec=False)",
            "",
            "def hook(l=None):",
			"    if l:",
			"        locals().update(l)",
			"    import IPython",
			"    IPython.embed(banner1='', confirm_exit=False)",
			"    exit(0)",
			"",
            "def breakpoint(location: str):",
            "    if gdb_api:",
            "        gdb_api.interrupt_and_wait()",
            "        gdb_api.Breakpoint(location)",
            "        gdb_api.continue_nowait()",
            "",
            "def exeGdb(cmd: str):",
            "    if gdb_api:",
            "        gdb_api.interrupt_and_wait()",
            "        gdb_api.execute(cmd)",
            "        gdb_api.continue_nowait()",
            "",
            "def vis(n: int = 10):",
            "    exeGdb(f'vis {n}')",
            "",
            "def one_gadget():",
            "    return [(int(i)+libc.address) for i in subprocess.check_output(['one_gadget', '--raw', local_libc_path]).decode().split(' ')]",
            "",
            "def _exitHandler():",
            "    if gdb_api:",
            "        gdb_api.quit()",
            "atexit.register(_exitHandler)",
            "",
            "def pwn_ssh(HOST, PORT):",
            "    user = input('ssh user: ')",
            "    password = input('ssh password: ')",
            "    return ssh(user=user, HOST=HOST, PORT=PORT, password=password)",
            "",
            "def pwn_gdb(io):",
            "    context.terminal = ['{{.applications.terminal.linux.command}}', '-e']",
            "    gdbscript = open(os.path.join(os.getenv('XDG_CONFIG_HOME'), 'gdb/init')).read()",
            "    gdbscript += '''",
            "init-pwndbg",
            "continue'''",
            "    return gdb.attach(io, gdbscript, api=True)",
            "",
            "# Find offset to EIP/RIP for buffer overflows",
            "def find_xip(payload, arch):",
            "    info(f'Finding offset to EIP/RIP for {arch}...')",
            "    # Launch process and send the overflow payload",
            "    io = process()",
            "    io.recv()",
            "    io.sendline(payload)",
            "    # Wait for the process to crash",
            "    io.wait()",
            "    if 'i386' in arch:",
            "        xip_offset = cyclic_find(io.corefile.pc)  # x86",
            "    elif '64' in arch:",
            "        xip_offset = cyclic_find(io.corefile.read(io.corefile.sp, 4))  # x64",
            "    info('The EIP/RIP offset is ')",
            "    success(str(xip_offset))",
            "    return int(xip_offset)",
            "",
            "def start():",
            "    HOST = '$2'",
            "    PORT = $3",
            "    if args.R:",
            "        if ':' in args.R:",
            "            HOST = args.R.split(':')[0]",
            "            PORT = args.R.split(':')[1]",
            "        elif not HOST or not PORT:",
            "            error('Please provide a HOST and PORT in the format HOST:PORT')",
            "            quit()",
            "        return remote(HOST, PORT)",
            "    elif args.S:",
            "        if ':' in args.S:",
            "            HOST = args.S.split(':')[0]",
            "            PORT = args.S.split(':')[1]",
            "        elif not HOST or not PORT:",
            "            error('Please provide a HOST and PORT in the format HOST:PORT')",
            "            quit()",
            "        return pwn_ssh(HOST, PORT)",
            "    elif args.L or args.GDB:",
            "        io = process()",
            "        if args.GDB:",
            "            global gdb_api",
            "            pid, gdb_api = pwn_gdb(io)",
            "        return io",
            "    else:",
            "        error('Please select an argument from [REMOTE(R), LOCAL(L), SSH(S), GDB(GDB)')",
            "        quit()",
            "# padding = find_xip(cyclic(250), elf_bin.get_machine_arch())",
            "io = start()",
            "breakpoint('main')",
            "$0",
            "#hook()",
            "io.interactive()"
        ],
    }
}
