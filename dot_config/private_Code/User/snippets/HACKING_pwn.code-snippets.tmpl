{
    "pwn template":{
        "scope": "python",
        "prefix": "pwn temp",
        "body": [
            "import os",
            "import shutil",
            "from pwnscripts import * #pip install pwnscripts",
            "",
            "binary_loc = './$1'",
            "context.binary = elf_bin = ELF(binary_loc, checksec=False)",
            "rop = ROP(elf_bin)",
            "gdb_api: gdb.Gdb = None",
            "HOST = '$2'",
            "PORT = $3",
            "",
            "#Wrapper functions",
            "_toBytes = lambda x : x.encode() if type(x) == str else x",
            "s = lambda x : io.send(_toBytes(x))",
            "sl = lambda x : io.sendline(_toBytes(x))",
            "sls = lambda x : io.sendlines(_toBytes(x))",
            "sa = lambda x, y : io.sendafter(_toBytes(x), _toBytes(y))",
            "sla = lambda x, y : io.sendlineafter(_toBytes(x), _toBytes(y))",
            "",
            "r = lambda x : io.recv(x)",
            "rn = lambda x : io.recvn(x)",
            "rl = lambda : io.recvline()",
            "rls = lambda : io.recvlines()",
            "ru = lambda x : io.recvuntil(_toBytes(x))",
            "rr = lambda x : io.recvregex(_toBytes(x))",
            "",
            "i = lambda : io.interactive()",
            "",
            "raddr = lambda: u64(r(6).ljust(8, b'\\x00'))",
            "",
            "# check if there is a libc binary in the current directory",
            "local_libc_path = './libc.so.6'",
            "if os.path.exists(local_libc_path):",
            "    context.libc_database = '{{.chezmoi.homeDir}}/HACKING/Tools/pwn/libc-database'",
            "    templ_libc_path = '/tmp/libc.so.6'",
            "    shutil.copy(local_libc_path, templ_libc_path)",
            "    context.libc = templ_libc_path",
            "    libc = context.libc",
            "",
            "def hook(l=None):",
			"    if l:",
			"        locals().update(l)",
			"    import IPython",
			"    IPython.embed(banner1='', confirm_exit=False)",
			"    exit(0)",
			"",
            "def breakpoint(location: str):",
            "    if args.GDB:",
            "        gdb_api.interrupt_and_wait()",
            "        gdb_api.Breakpoint(location)",
            "        gdb_api.continue_nowait()",
            "",
            "def exeGdb(cmd: str):",
            "    if args.GDB:",
            "        gdb_api.interrupt_and_wait()",
            "        gdb_api.execute(cmd)",
            "        gdb_api.continue_nowait()",
            "",
            "def vis(n: int = 10):",
            "    exeGdb(f'vis {n}')",
            "",
            "# Handlers",
            "def _exitHandler():",
            "    if args.GDB:",
            "        gdb_api.quit()",
            "atexit.register(_exitHandler)",
            "",
            "def pwn_ssh(host, port):",
            "    user = input('ssh user: ')",
            "    password = input('ssh password: ')",
            "    return ssh(user=user, host=host, port=port, password=password)",
            "",
            "def pwn_gdb(argv):",
            "    context.terminal = ['{{.applications.terminal.linux.command}}', '-e']",
            "    gdbscript = open(os.path.join(os.getenv('XDG_CONFIG_HOME', '{{.chezmoi.homeDir}}/.config'), 'gdb/init')).read()",
            "    gdbscript += '''",
            "    init-pwndbg",
            "    continue'''",
            "    return gdb.debug([elf_bin.path] + argv, gdbscript, env={}, api=True)",
            "",
            "log_addr = lambda name, address: info(f'{name} @ {hex(address)}')",
            "",
            "# Find offset to EIP/RIP for buffer overflows",
            "def find_xip(payload, arch):",
            "    info(f'Finding offset to EIP/RIP for {arch}...')",
            "    # Launch process and send the overflow payload",
            "    io = process()",
            "    io.recv()",
            "    io.sendline(payload)",
            "    # Wait for the process to crash",
            "    io.wait()",
            "    if 'i386' in arch:",
            "        xip_offset = cyclic_find(io.corefile.pc)  # x86",
            "    elif '64' in arch:",
            "        xip_offset = cyclic_find(io.corefile.read(io.corefile.sp, 4))  # x64",
            "    info('The EIP/RIP offset is ')",
            "    success(str(xip_offset))",
            "    return int(xip_offset)",
            "",
            "def start(argv = []):",
            "    global HOST, PORT",
            "    if args.R:",
            "        if ':' in args.R:",
            "            host = args.R.split(':')[0]",
            "            port = args.R.split(':')[1]",
            "        elif not HOST or not PORT:",
            "            error('Please provide a host and port in the format host:port')",
            "            quit()",
            "        return remote(host, port)",
            "    elif args.S:",
            "        if ':' in args.S:",
            "            host = args.S.split(':')[0]",
            "            port = args.S.split(':')[1]",
            "        elif not HOST or not PORT:",
            "            error('Please provide a host and port in the format host:port')",
            "            quit()",
            "        return pwn_ssh(host, port)",
            "    elif args.L:",
            "        return process([elf_bin.path] + argv)",
            "    elif args.GDB:",
            "        io = pwn_gdb(argv)",
            "        gdb_api = io.gdb",
            "        return pwn_gdb(argv)",
            "    else:",
            "        error('Please select an argument from [REMOTE(R), LOCAL(L), SSH(S), GDB(GDB)')",
            "        quit()",
            "# padding = find_xip(cyclic(250), elf_bin.get_machine_arch())",
            "io = start()",
            "$0",
            "#hook()"
        ],
    }
}
