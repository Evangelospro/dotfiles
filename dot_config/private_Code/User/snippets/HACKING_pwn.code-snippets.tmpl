{
    "pwn template":{
        "scope": "python",
        "prefix": "pwn temp",
        "body": [
            "import os",
            "import shutil",
            "from pwnscripts import * #pip install pwnscripts",
            "",
            "# Lamda helpers",
            "sl = lambda x: io.sendline(x.encode() if type(x) == str else x)",
            "sla = lambda x, y: io.sendlineafter(x.encode() if type(x) == str else x, y.encode() if type(y) == str else y)",
            "se = lambda x: io.send(x.encode() if type(x) == str else x)",
            "sa = lambda x, y: io.sendafter(x.encode() if type(x) == str else x, y.encode() if type(y) == str else y)",
            "uu64 = lambda x: u64(x.ljust(8, b'\\x00'))",
            "uuu = lambda x: unhex(x[2:])",
            "",
            "# check if there is a libc binary in the current directory",
            "local_libc_path = './libc.so.6'",
            "if os.path.exists(local_libc_path):",
            "    context.libc_database = '{{.chezmoi.homeDir}}/HACKING/Tools/pwn/libc-database'",
            "    templ_libc_path = '/tmp/libc.so.6'",
            "    shutil.copy(local_libc_path', templ_libc_path)",
            "    context.libc = templ_libc_path",
            "    libc = context.libc",
            "",
            "binary_loc = './$1'",
            "context.binary = elf_bin = ELF(binary_loc, checksec=False)",
            "",
            "HOST = '$2'",
            "PORT = $3",
            "",
            "def pwn_ssh(host, port):",
            "    user = input('ssh user: ')",
            "    password = input('ssh password: ')",
            "    return ssh(user=user, host=host, port=port, password=password)",
            "",
            "def pwn_gdb():",
            "    context.terminal = ['{{.applications.terminal.linux.command}}', '-e']",
            "    gdbscript = open(os.path.join(os.getenv('XDG_CONFIG_HOME', '{{.chezmoi.homeDir}}/.config'), 'gdb/init')).read()",
            "    gdbscript += '''",
            "    init-pwndbg",
            "    continue'''",
            "    return gdb.debug(elf_bin.path, gdbscript, env={})",
            "",
            "log_addr = lambda name, address: info(f'{name} @ {hex(address)}')",
            "",
            "log_base = lambda: log_addr('Libc base', libc.address)",
            "",
            "# Find offset to EIP/RIP for buffer overflows",
            "def find_xip(payload, arch):",
            "    info(f'Finding offset to EIP/RIP for {arch}...')",
            "    # Launch process and send the overflow payload",
            "    io = process()",
            "    io.recv()",
            "    io.sendline(payload)",
            "    # Wait for the process to crash",
            "    io.wait()",
            "    if 'i386' in arch:",
            "        xip_offset = cyclic_find(io.corefile.pc)  # x86",
            "    elif '64' in arch:",
            "        xip_offset = cyclic_find(io.corefile.read(io.corefile.sp, 4))  # x64",
            "    info('The EIP/RIP offset is ')",
            "    success(str(xip_offset))",
            "    return int(xip_offset)",
            "",
            "",
            "def start(host=HOST, port=PORT):",
            "    if args.R:",
            "        if ':' in args.R:",
            "            host = args.R.split(':')[0]",
            "            port = args.R.split(':')[1]",
            "        elif not host or not port:",
            "            error('Please provide a host and port in the format host:port')",
            "            quit()",
            "        return remote(host, port)",
            "    elif args.S:",
            "        if ':' in args.S:
            "            host = args.S.split(':')[0]",
            "            port = args.S.split(':')[1]",
            "        elif not host or not port:",
            "            error('Please provide a host and port in the format host:port')",
            "            quit()",
            "        return pwn_ssh(host, port)",
            "    elif args.L:",
            "        return process()",
            "    elif args.GDB:",
            "        return pwn_gdb()",
            "    else:",
            "        error('Please select an argument from [REMOTE(R), LOCAL(L), SSH(S), GDB(GDB)')",
            "        quit()",
            "padding = find_xip(cyclic(250), elf_bin.get_machine_arch())",
            "io = start()",
            "$0",
            "#io.interactive()",
        ],
    }
}
