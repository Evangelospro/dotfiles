# Maintenance is hard...
function update(){
    paru -Syu
    zi self-update
    zi update
    pkgfile -u
    $HOME/.config/hypr/plugins/update.sh
    navi-update
}

function upload(){
    if [[ -z $1 ]]; then
        echo "No file specified for upload"
        return 1
    fi
    full_path=$(realpath $1)
    curl --silent -F"file=@$full_path" https://0x0.st|copy && paste
}

function mkcdir(){
    mkdir -p $1
    cd $1
}

# Move latest Download to current directory
function mvd() {
    local fileName
    # check that the user is not in the Downloads directory already
    if [[ $(pwd) == "$HOME"/Downloads ]]; then
        echo "Already in Downloads directory"
        return 1
    else
        fileName=$(\ls -t $HOME/Downloads | head -n 1)
        # check that the command was completed successfully and has an output
        if [[ $? == 0 && -n $fileName ]]; then
            # Check if file doesn't end with .crdownload ignore casing
            if [[ ${(L)fileName} != *.crdownload ]]; then
                mv $HOME/Downloads/"$fileName" .
            else
                echo $fileName has not finished downloading
            fi
        else
            echo "No files in Downloads"
            return 1
        fi
    fi
}

# Move latest Screenshot to current directory
function mvs() {
    # check that the user is not in the Screenshots directory already
    if [[ $(pwd) == "$HOME"/Pictures/Screenshots ]]; then
        echo "Already in Screenshots directory"
        return 1
    else
        local fileName
        fileName=$(\ls -t $HOME/Pictures/Screenshots | head -n 1)
        # check that the command was completed successfully and has an output
        if [[ $? == 0 && -n $fileName ]]; then
            mv $HOME/Pictures/Screenshots/"$fileName" .
        else
            echo "No files in Screenshots"
            return 1
        fi
    fi
}

function checkContainerRunning() {
    docker container ls -q -f name="$1"
}

function pwnenv() {
    if [ $(checkContainerRunning "pwnenv") ]; then
        echo "Container already running, attaching..."
        docker exec -it pwnenv zsh
    else
        echo "Starting container..."
        docker run --net=host --cap-add=SYS_PTRACE --security-opt seccomp=unconfined --rm -it -v "$(pwd)":/root/data --name pwnenv ghcr.io/evangelospro/pwnenv:latest
    fi
}

# An all in one extract function for all archive types
function ex {
    if [ -z "$1" ]; then
        # display usage if no parameters given
        echo "Usage: ex <path/file_name>.<zip|rar|bz2|gz|tar|tbz2|tgz|Z|7z|xz|ex|tar.bz2|tar.gz|tar.xz>"
        echo "       ex <path/file_name_1.ext> [path/file_name_2.ext] [path/file_name_3.ext]"
    else
        for n in "$@"
        do
            if [ -f "$n" ] ; then
                case "${n%,}" in
                    *.cbt|*.tar.bz2|*.tar.gz|*.tar.xz|*.tbz2|*.tgz|*.txz|*.tar)
                    tar xvf "$n"       ;;
                    *.lzma)      unlzma ./"$n"      ;;
                    *.bz2)       bunzip2 ./"$n"     ;;
                    *.cbr|*.rar)       unrar x -ad ./"$n" ;;
                    *.gz)        gunzip ./"$n"      ;;
                    *.cbz|*.epub|*.zip)       unzip ./"$n"       ;;
                    *.z)         uncompress ./"$n"  ;;
                    *.7z|*.arj|*.cab|*.cb7|*.chm|*.deb|*.dmg|*.iso|*.lzh|*.msi|*.pkg|*.rpm|*.udf|*.wim|*.xar)
                    7z x ./"$n"        ;;
                    *.xz)        unxz ./"$n"        ;;
                    *.exe)       cabextract ./"$n"  ;;
                    *.cpio)      cpio -id < ./"$n"  ;;
                    *.cba|*.ace)      unace x ./"$n"      ;;
                    *)
                        echo "ex: '$n' - unknown archive method"
                        return 1
                    ;;
                esac
            else
                echo "'$n' - file does not exist"
                return 1
            fi
        done
    fi
}

# colorized man pages
man() {
    env \
    LESS_TERMCAP_mb=$(printf "\e[1;31m") \
    LESS_TERMCAP_md=$(printf "\e[1;35m") \
    LESS_TERMCAP_me=$(printf "\e[0m") \
    LESS_TERMCAP_se=$(printf "\e[0m") \
    LESS_TERMCAP_so=$(printf "\e[4;36m") \
    LESS_TERMCAP_ue=$(printf "\e[0m") \
    LESS_TERMCAP_us=$(printf "\e[3;34m") \
    PAGER="${commands[less]:-$PAGER}" \
    _NROFF_U=1 \
    PATH="$HOME/bin:$PATH" \
    man "$@"
}

# navigation
up () {
    local d=""
    local limit="$1"

    # Default to limit of 1
    if [ -z "$limit" ] || [ "$limit" -le 0 ]; then
        limit=1
    fi

    for ((i=1;i<=limit;i++)); do
        d="../$d"
    done

    # perform cd. Show error if cd fails
    if ! cd "$d"; then
        echo "Couldn't go up $limit dirs.";
    fi
}

function rm(){
    this_file_system=$(df -P $HOME | tail -1 | awk '{print $1}')
    flags=()
    targets=()
    for arg in "$@"; do
        if [[ $arg == -* ]]; then
            flags+=("$arg")
        else
            targets+=("$arg")
        fi
    done
    if [[ -z $targets ]]; then
        echo "No targets specified"
        return 1
    fi
    # echo "targets: ${targets[@]}"
    # echo "flags: $flags"
    for target in "${targets[@]}"; do
        target_file_system=$(df -P $target 2>/dev/null | tail -1 | awk '{print $1}')
        if [[ $target_file_system == $this_file_system ]]; then
            trash-put $target
        else
            # if flags is empty, don't pass it to rm
            if [[ -z $flags ]]; then
                /usr/bin/rm $target
            else
                flags="${flags[@]}"
                /usr/bin/rm $flags $target
            fi
        fi
    done
}

# Adding onefetch to every cd you do with a .git dir
cd () {
    __zoxide_z "$@"
    git rev-parse 2> /dev/null
    if [ $? -eq 0 ]
    then
        if [ "$LAST_REPO" != $(basename "$(git rev-parse --show-toplevel)") ]
        then
            onefetch
            LAST_REPO=$(basename "$(git rev-parse --show-toplevel)")
        fi
    fi
}

# Time shell loading time
timeshell() {
    shell=${1-$SHELL}
    for i in $(seq 1 10); do time $shell -i -c exit; done
}

# Hacking

## Android
function frida-init(){
    if [[ -z $1 ]]; then
        device=$(adb devices|tail -n +2 | cut -f1)
        # if the device is not an emulator connect via tcp
        if [[ $device == *emulator* ]]; then
            echo "Device is an emulator, no need to connect via tcp"
        else
            echo "Device is not an emulator, connecting via tcp"
            adb connect $device
        fi
    else
        device=$1
        adb connect $device
    fi
    # cleanup old frida-server
    \rm -f /tmp/frida*
    adb root
    adb remount
    frida_version=$(frida --version)
    arch=$(adb shell getprop ro.product.cpu.abi)
    wget --show-progress -q "https://github.com/frida/frida/releases/download/$frida_version/frida-server-$frida_version-android-$arch.xz" -O /tmp/frida-server.xz
    unxz /tmp/frida-server.xz
    # disable this usap feature, it causes issues with frida
    adb shell setprop persist.device_config.runtime_native.usap_pool_enabled false
    adb push -p /tmp/frida-server /data/local/tmp/
    adb shell 'chmod 755 /data/local/tmp/frida-server'
    # kill any running frida-server
    adb shell 'killall frida-server'
    adb shell '/data/local/tmp/frida-server -D'
}

function frida-kill(){
    adb shell 'killall frida-server'
}

getWorlist() {
    # because seclists gets updated a lot and I really want .git to be in my preferred wordlist
    defaultDirWordlist="/usr/share/seclists/Discovery/Web-Content/directory-list-lowercase-2.3-medium.txt"
    defaultDnsWordlist="/usr/share/seclists/Discovery/DNS/subdomains-top1million-110000.txt"
    modifiedWordlist="/tmp/modifiedWordlist.txt"
    if [[ $1 == "dir" ]]; then
        cp $defaultDirWordlist $modifiedWordlist
        sed -i '1s/^/.git\n/' $modifiedWordlist
        echo $modifiedWordlist
        elif [[ $1 == "dns" ]]; then
        cp $defaultDnsWordlist $modifiedWordlist
        echo $modifiedWordlist
    else
        echo "Usage: getWordlist <dir|dns>"
    fi
}

scan() {
    \rustscan --ulimit 5000 -b 3000 -a $1 -- -sC -sV
}

urlencode() {
    python3 -c "from pwn import *; print(urlencode('$1'));"
}

urldecode() {
    python3 -c "from pwn import *; print(urldecode('$1'));"
}

ffuf-vhost() {
    arg_count=3
    if [[ $2 && $2 != -* ]]; then
        wordlist=$2
    else
        wordlist=$(getWorlist dns)
        arg_count=2
    fi
    ffuf -c -H "Host: FUZZ.$1" -u http://$1 -w $wordlist ${@: $arg_count};
}

ferox-dir() {
    arg_count=3
    if [[ $2 && $2 != -* ]]; then
        wordlist=$2
    else
        wordlist=$(getWorlist dir)
        arg_count=2
    fi
    feroxbuster -u $1 -w $wordlist ${@: $arg_count};
}

ffuf-dir() {
    arg_count=3
    if [[ $2 && $2 != -* ]]; then
        wordlist=$2
    else
        wordlist=$(getWorlist dir)
        arg_count=2
    fi
    ffuf -c -u $1FUZZ -w $wordlist ${@: $arg_count};
}


ffuf-ext() {
    exts=(php html phps asp bak)
    arg_count=3
    if [[ $2 && $2 != -* ]]; then
        wordlist=$2
    else
        wordlist=$(getWorlist dir)
        arg_count=2
    fi
    ffuf -c -u $1FUZZ -w $wordlist ${@: $arg_count} -x ${exts[@]};
}

ferox-ext() {
    exts=(php html phps asp bak)
    arg_count=3
    if [[ $2 && $2 != -* ]]; then
        wordlist=$2
    else
        wordlist=$(getWorlist dir)
        arg_count=2
    fi
    feroxbuster -u $1 -w $wordlist -x ${exts[@]} ${@: $arg_count};
}

ffuf-req-dir() {
    arg_count=3
    if [[ $2 && $2 != -* ]]; then
        wordlist=$2
    else
        wordlist=$(getWorlist dir)
        arg_count=2
    fi
    ffuf -c -ic -request $1 -request-proto http -w $wordlist ${@: $arg_count};
}

ffuf-req-ext() {
    exts=(php html phps asp bak)
    arg_count=3
    if [[ $2 && $2 != -* ]]; then
        wordlist=$2
    else
        wordlist=$(getWorlist dir)
        arg_count=2
    fi
    ffuf -c -ic -request $1 -request-proto http -w $wordlist -x ${exts[@]} ${@: $arg_count};
}

listener() {
    if [[ $1 ]]; then
        port=$1
    else
        port=1337
    fi
    stty raw -echo; (echo export TERM=xterm;echo 'python3 -c "import pty;pty.spawn(\"/bin/bash\")" || python -c "import pty;pty.spawn(\"/bin/bash\")"' ;echo "stty$(stty -a | awk -F ';' '{print $2 $3}' | head -n 1)"; echo reset;cat) | nc -lvnp $port && reset
}

# sshp username password host extr_args
sshp() {
    sshpass -p $2 ssh -o StrictHostKeyChecking=no $1@$3 ${@: 4};
}

# ECSC
ataka_completion() {
    eval $(env _TYPER_COMPLETE_ARGS="${words[1,$CURRENT]}" _PYTHON _M ATAKA_COMPLETE=complete_zsh python -m ataka)
}
